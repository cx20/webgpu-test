<!DOCTYPE html>
<html>
<head>
  <title>[WebGPU] Composite glTF Models with Skinning Animation</title>
  <style>
    * { margin: 0; padding: 0; }
    body { overflow: hidden; background: #000; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>

<!-- Main Vertex Shader -->
<script id="vs" type="x-shader/x-vertex">
struct Uniforms {
    modelMatrix: mat4x4<f32>,
    viewMatrix: mat4x4<f32>,
    projectionMatrix: mat4x4<f32>,
    normalMatrix: mat4x4<f32>,
    lightDir: vec4<f32>,
    baseColor: vec4<f32>,
    flags: vec4<u32>  // x: hasSkinning, y: hasTexture, z: hasNormals
};

struct JointMatrices {
    matrices: array<mat4x4<f32>, 180>
};

@binding(0) @group(0) var<uniform> uniforms: Uniforms;
@binding(1) @group(0) var<storage, read> jointMatrices: JointMatrices;

struct VertexInput {
    @location(0) position: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) texCoord: vec2<f32>,
    @location(3) joints: vec4<u32>,
    @location(4) weights: vec4<f32>
};

struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) vNormal: vec3<f32>,
    @location(1) vTexCoord: vec2<f32>,
    @location(2) vPosition: vec3<f32>,
    @location(3) vWorldPosition: vec3<f32>
};

@vertex
fn main(input: VertexInput) -> VertexOutput {
    var output: VertexOutput;
    
    var position = vec4<f32>(input.position, 1.0);
    var normal = input.normal;
    
    if (uniforms.flags.x == 1u) {
        let skinMatrix = 
            input.weights.x * jointMatrices.matrices[input.joints.x] +
            input.weights.y * jointMatrices.matrices[input.joints.y] +
            input.weights.z * jointMatrices.matrices[input.joints.z] +
            input.weights.w * jointMatrices.matrices[input.joints.w];
        
        position = skinMatrix * position;
        normal = (skinMatrix * vec4<f32>(normal, 0.0)).xyz;
    }
    
    let worldPosition = uniforms.modelMatrix * position;
    output.vPosition = worldPosition.xyz;
    output.vWorldPosition = worldPosition.xyz;
    output.vNormal = (uniforms.normalMatrix * vec4<f32>(normal, 0.0)).xyz;
    output.vTexCoord = input.texCoord;
    output.position = uniforms.projectionMatrix * uniforms.viewMatrix * worldPosition;
    
    return output;
}
</script>

<!-- Main Fragment Shader -->
<script id="fs" type="x-shader/x-fragment">
struct Uniforms {
    modelMatrix: mat4x4<f32>,
    viewMatrix: mat4x4<f32>,
    projectionMatrix: mat4x4<f32>,
    normalMatrix: mat4x4<f32>,
    lightDir: vec4<f32>,
    baseColor: vec4<f32>,
    flags: vec4<u32>
};

@binding(0) @group(0) var<uniform> uniforms: Uniforms;
@binding(2) @group(0) var texSampler: sampler;
@binding(3) @group(0) var texTexture: texture_2d<f32>;

struct FragmentInput {
    @location(0) vNormal: vec3<f32>,
    @location(1) vTexCoord: vec2<f32>,
    @location(2) vPosition: vec3<f32>,
    @location(3) vWorldPosition: vec3<f32>
};

@fragment
fn main(input: FragmentInput) -> @location(0) vec4<f32> {
    var normal: vec3<f32>;
    
    // Use interpolated normals if available, otherwise use flat shading
    if (uniforms.flags.z == 1u) {
        // Has normals: use interpolated normal
        normal = normalize(input.vNormal);
    } else {
        // No normals: compute normal from surface derivatives for flat shading
        // In screen space, we compute the normal using dFdx and dFdy
        // dFdx returns the derivative of the input with respect to the screen x coordinate
        // dFdy returns the derivative of the input with respect to the screen y coordinate
        let ddx = dpdx(input.vWorldPosition);
        let ddy = dpdy(input.vWorldPosition);
        normal = normalize(cross(ddx, ddy));
    }
    
    let lightDir = normalize(uniforms.lightDir.xyz);
    
    let diff = max(dot(normal, lightDir), 0.0);
    let ambient = 0.3;
    let lighting = ambient + diff * 0.7;
    
    var baseColor: vec4<f32>;
    if (uniforms.flags.y == 1u) {
        baseColor = textureSample(texTexture, texSampler, input.vTexCoord);
    } else {
        baseColor = uniforms.baseColor;
    }
    
    var finalColor = baseColor.rgb * lighting;
    finalColor = pow(finalColor, vec3<f32>(1.0 / 2.2));
    
    return vec4<f32>(finalColor, baseColor.a);
}
</script>

<!-- Skybox Vertex Shader -->
<script id="vs-skybox" type="x-shader/x-vertex">
struct SkyboxUniforms {
    projectionMatrix: mat4x4<f32>,
    viewMatrix: mat4x4<f32>
};

@binding(0) @group(0) var<uniform> uniforms: SkyboxUniforms;

struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) vTexCoord: vec3<f32>
};

@vertex
fn main(@location(0) position: vec3<f32>) -> VertexOutput {
    var output: VertexOutput;
    output.vTexCoord = position;
    
    let pos = uniforms.projectionMatrix * uniforms.viewMatrix * vec4<f32>(position, 1.0);
    output.position = vec4<f32>(pos.xy, pos.w, pos.w);  // z = w for depth = 1.0
    
    return output;
}
</script>

<!-- Skybox Fragment Shader -->
<script id="fs-skybox" type="x-shader/x-fragment">
@binding(1) @group(0) var skyboxSampler: sampler;
@binding(2) @group(0) var skyboxTexture: texture_cube<f32>;

@fragment
fn main(@location(0) vTexCoord: vec3<f32>) -> @location(0) vec4<f32> {
    return textureSample(skyboxTexture, skyboxSampler, vTexCoord);
}
</script>

<canvas id="c"></canvas>
<script src="https://unpkg.com/gl-matrix@3.4.4/gl-matrix-min.js"></script>
<script type="module" src="index.js"></script>
</body>
</html>